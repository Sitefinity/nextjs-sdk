import { deepCopy } from '../utils/object-utils';
import { EditorMetadata } from './widget-editor-metadata';

export type WidgetViewsRegistration = { [key: string]: Function | { Title: string, ViewFunction: Function } };

/**
 * Represents a minimum subset of the widget's metadata that is safe for transfer from the server to the client.
 */
export interface WidgetMetadataBase {
    /**
     * The widget's designer metadata - a JSON object that contains the widget's properties with all their metadata.
     * It is used to generate the widget's designer (configuration UI).
     * It will be automatically generated by the framework based on the provided entity and should not be modified.
     * It can be used instead of providing the entity class function.
     */
    designerMetadata?: any;

    /**
     * Specifies the widget's properties and behavior in the editor - category, toolbox, section, icons, labels, empty text, etc.
     */
    editorMetadata?: EditorMetadata;

    /**
     * Specifies whether the widget should be rendered on the server side or not.
     */
    ssr?: boolean;

    /**
     * Optional default values for any of the widget's properties.
     * This will override the default values defined in the entity/designer metadata.
     */
    defaultValues?: any;
}

/**
 * Represents the widget's metadata that should be registered in the widget registry.
 * This metadata consists at minimum of the widget's entity, editor metadata, SSR flag, and the widget's React component function.
 * It allows the widget to be available in the Page editor and to be rendered in the Sitefinity Next.js Renderer.
 */
export interface WidgetMetadata extends WidgetMetadataBase {
    /**
     * The widget's corresponding React component function.
     */
    componentType: any;

    /**
     * The widget's entity class function.
     */
    entity?: any;

    /**
     * @deprecated: Use 'views' property instead.
     */
    templates?: WidgetViewsRegistration;

    /**
     * The widget's views registration - an object providing implementations for the optional different ways to render the component.
     * The widget should implement a {@link RenderView} component in its output and a SfViewName property in its entity class to be able to use views.
     * The views are provided as a dictionary of view names and an object for their corresponding React components and friendly name.
     */
    views?: WidgetViewsRegistration;
}

export function getMinimumMetadata(metadata: WidgetMetadata, isEdit: boolean): WidgetMetadataBase {
    if (!isEdit) {
        return {
            ssr: metadata?.ssr
        };
    }

    return deepCopy<WidgetMetadataBase>({
        designerMetadata: metadata?.designerMetadata,
        defaultValues: metadata?.defaultValues,
        editorMetadata: metadata?.editorMetadata,
        ssr: metadata?.ssr
    });
}
